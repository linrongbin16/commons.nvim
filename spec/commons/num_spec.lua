local cwd = vim.fn.getcwd()

describe("commons.num", function()
  local assert_eq = assert.is_equal
  local assert_true = assert.is_true
  local assert_false = assert.is_false
  local assert_truthy = assert.is.truthy
  local assert_falsy = assert.is.falsy

  before_each(function()
    vim.api.nvim_command("cd " .. cwd)
  end)

  local num = require("commons.num")

  describe("[test]", function()
    it("INT32_MIN/INT32_MAX", function()
      assert_eq(num.INT32_MAX, 2 ^ 31 - 1)
      assert_eq(num.INT32_MIN, -(2 ^ 31))
    end)
    it("eq/ne", function()
      assert_true(num.eq(1, 1))
      assert_false(num.eq(nil, 1))
      assert_false(num.eq("a", 1))
      assert_false(num.ne(1, 1))
      assert_true(num.ne(nil, 1))
      assert_true(num.ne("a", 1))
    end)
    it("eq/ne floats approximate", function()
      assert_true(num.eq(1.123, 1.124, 0.1, 0.1))
      assert_true(num.eq(1.123, 1.124, 0.01, 0.01))
      assert_true(num.eq(1.123, 1.124, 0.001, 0.001))
      assert_false(num.eq(1.123, 1.124, 0.0001, 0.0001))
      assert_false(num.eq(1.123, 1.124))

      assert_false(num.ne(1.123, 1.124, 0.1, 0.1))
      assert_false(num.ne(1.123, 1.124, 0.01, 0.01))
      assert_false(num.ne(1.123, 1.124, 0.001, 0.001))
      assert_true(num.ne(1.123, 1.124, 0.0001, 0.0001))
      assert_true(num.ne(1.123, 1.124))
    end)
    it("lt/le", function()
      assert_true(num.lt(1, 2))
      assert_false(num.lt(nil, 1))
      assert_false(num.lt("a", 1))
      assert_true(num.le(1, 1))
      assert_false(num.le(nil, 1))
      assert_false(num.le("a", 1))
    end)
    it("lt/le floats approximate", function()
      assert_false(num.lt(1.123, 1.124, 0.1, 0.1))
      assert_false(num.lt(1.123, 1.124, 0.01, 0.01))
      assert_false(num.lt(1.123, 1.124, 0.001))
      assert_true(num.lt(1.123, 1.124, 0.0001))
      assert_true(num.lt(1.123, 1.124))

      assert_true(num.le(1.125, 1.124, 0.1))
      assert_true(num.le(1.125, 1.124, 0.01))
      assert_true(num.le(1.125, 1.124, 0.001))
      assert_false(num.le(1.125, 1.124, 0.0001))
      assert_false(num.le(1.125, 1.124))
    end)
    it("gt/ge", function()
      assert_true(num.gt(2, 1))
      assert_false(num.gt(1, nil))
      assert_false(num.gt("a", 1))
      assert_true(num.ge(1, 1))
      assert_false(num.ge(1, nil))
      assert_false(num.ge("a", 1))
    end)
    it("gt/ge floats approximate", function()
      assert_false(num.gt(2.17, 2.18, 0.1))
      assert_false(num.gt(2.17, 2.18, 0.01, 0.01))
      assert_false(num.gt(2.17, 2.18))
      assert_true(num.gt(2.19, 2.18))

      assert_true(num.ge(2.17, 2.18, 0.1))
      assert_true(num.ge(2.17, 2.18, 0.01, 0.01))
      assert_false(num.ge(2.17, 2.18))
      assert_true(num.ge(2.19, 2.18))
    end)
    it("bound", function()
      assert_eq(num.bound(5, 1, 3), 3)
      assert_eq(num.bound(2, 1, 13), 2)
      assert_eq(num.bound(77), 77)
      assert_eq(num.bound(77, nil, 29), 29)
    end)
    it("bound left", function()
      assert_eq(num.bound(1, 1, 2), 1)
      assert_eq(num.bound(1, 2, 3), 2)
      assert_eq(num.bound(1, 3, 4), 3)
      assert_eq(num.bound(2, 3, 4), 3)
      assert_eq(num.bound(3, 3, 4), 3)
      assert_eq(num.bound(4, 3, 4), 4)
      assert_eq(num.bound(-10, nil), -10)
    end)
    it("bound right", function()
      assert_eq(num.bound(1, 1, 5), 1)
      assert_eq(num.bound(3, 2, 6), 3)
      assert_eq(num.bound(5, 3, 7), 5)
      assert_eq(num.bound(9, 3, 8), 8)
      assert_eq(num.bound(10, 3, 9), 9)
      assert_eq(num.bound(15, 3, 10), 10)
      assert_eq(num.bound(15, 3), 15)
    end)
    it("auto_incremental_id", function()
      local id1 = num.auto_incremental_id()
      assert_true(id1 >= 1)
      local id2 = num.auto_incremental_id()
      assert_eq(id2, id1 + 1)
      local id3 = num.auto_incremental_id()
      assert_eq(id3, id2 + 1)
      assert_true(num.auto_incremental_id() == num.auto_incremental_id() - 1)
    end)
    it("mod", function()
      assert_eq(num.mod(2, 7), 2)
      assert_eq(num.mod(10, 7), 3)
      assert_eq(num.mod(10, 1), 0)
      assert_eq(num.mod(7, 6), 1)
    end)
    it("max", function()
      assert_eq(num.max(string.len, "a", "bc", "def"), "def")
      local ok, err = pcall(num.max, "a", "bc", "def")
      assert_false(ok)
      assert_eq(num.max(string.len, "a"), "a")
    end)
    it("min", function()
      assert_eq(num.min(string.len, "a", "bc", "def"), "a")
      local ok, err = pcall(num.min, "a", "bc", "def")
      assert_false(ok)
      assert_eq(num.min(string.len, "a"), "a")
    end)
    it("random", function()
      for i = 1, 50 do
        local actual1 = num.random()
        print(string.format("random-1(%s):%s\n", vim.inspect(type(actual1)), vim.inspect(actual1)))
        assert_true(actual1 >= 0 and actual1 < 1)
      end
      for i = 1, 50 do
        local actual2 = num.random(10)
        print(string.format("random-2(%s):%s\n", vim.inspect(type(actual2)), vim.inspect(actual2)))
        assert_true(actual2 >= 1 and actual2 <= 10)
      end
      for i = 1, 50 do
        local actual3 = num.random(10, 100)
        print(string.format("random-3(%s):%s\n", vim.inspect(type(actual3)), vim.inspect(actual3)))
        assert_true(actual3 >= 10 and actual3 <= 100)
      end
    end)
    it("shuffle", function()
      local input = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 }
      local last_actual = vim.deepcopy(input)
      for i = 1, 50 do
        local actual = num.shuffle(input)
        assert_false(vim.deep_equal(input, actual))
        assert_false(vim.deep_equal(last_actual, actual))
        last_actual = vim.deepcopy(actual)
      end
    end)
  end)
end)
